/*
 * Copyright (C) 2010-2011  George Parisis and Dirk Trossen
 * All rights reserved.
 * TCLAP and PlanetLab support By Dimitris Syrivelis
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * Alternatively, this software may be distributed under the terms of
 * the BSD license.
 *
 * See LICENSE and COPYING for more details.
 */

#include "network.hpp"
#include "graph_representation.hpp"
#include "parser.hpp"
#include <tclap/CmdLine.h>


using namespace std;

int main(int argc, char **argv) {
    int ret;
    string filename;
    string tgzfile;
    bool autogenerate = false;
    bool ns3 = false;
    bool transfer_binaries = false;
    bool monitor_tool_stub = false;
    bool dump_supp = false;
    bool no_discover = false;
    bool no_copy = false;
    bool no_start = false;

    /**parse command line block based on TCLAP (template lib)
     */
    try {
        TCLAP::CmdLine cmd("Blackadder Universal Deployment Tool ", ' ', "0.4");
        TCLAP::ValueArg<std::string> configfileArg("c", "configfile", "Configuration file that contains graph attributes OR describes a graph (when -a is not used)", true, "homer", "string");
        TCLAP::ValueArg<std::string> tgzfileArg("t", "tgzfile", "tar gzipped file that gets transferred and extracted at USER home folders on all experiment targets", false, "None", "string");
        TCLAP::SwitchArg MonToolStubSwitch("m", "montoolstub", "Enable monitor tool stub in the Click configuration files. This injects counters in click configs that are inspected at runtime via port 55000. It will be ommited for kernel versions", cmd, false);
        TCLAP::SwitchArg dumpSupp("", "rvinfo", "Enable RV info dump support (on port 55500 in the RV node if it is running on userlevel).", cmd, false);
        TCLAP::SwitchArg autoSwitch("a", "auto", "Enable graph autogeneration - a autogenerated.cfg and edgevertices.cfg files are emitted at WRITE_CONF folder. The former contains the graph to repeat the experiment and the latter the leaf nodes", cmd, false);
        TCLAP::SwitchArg ns3Switch("s", "simulate", "if this flag is on a C++ ns3 simulation description will be created", cmd, false);
        TCLAP::SwitchArg noDiscover("", "nodiscover", "Don't auto-discover MAC addresses.", cmd, false);
        TCLAP::SwitchArg noCopy("", "nocopy", "Don't copy files to nodes.", cmd, false);
        TCLAP::SwitchArg noStart("", "nostart", "Don't start/stop Click.", cmd, false);

        cmd.add(configfileArg);
        cmd.add(tgzfileArg);
        cmd.parse(argc, argv);

        /**get config filename. This is mandatory argument so we can skip existence check
         */
        filename = configfileArg.getValue();
        tgzfile = tgzfileArg.getValue();
        /** check if autogenerate flag was set
         */
        autogenerate = autoSwitch.getValue();
        /** check if ns3 simulation code must be created
         */
        ns3 = ns3Switch.getValue();
        /**if experiment file argument is not the default value the experiment deploy flag should be true
         */
        if (tgzfile != string("None")) {
            transfer_binaries = true;
        }
        /**Get monitor tool stub flag
         */
        monitor_tool_stub = MonToolStubSwitch.getValue();
        if ((ns3 && autogenerate) || (ns3 && monitor_tool_stub)) {
            cout << "You can't have it all!! ns3 switch must not be combined with the auto switch or the monitor tool switch" << endl;
            exit(1);
        }
        dump_supp = dumpSupp.getValue();
        no_discover = noDiscover.getValue();
        no_copy = noCopy.getValue();
        no_start = noStart.getValue();
    } catch (TCLAP::ArgException &e)
        /**catch any command parsing exceptions
         */ {
        std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl;
    }

    /**if autogenerated flag is set, a autogenerated file is built and it is then loaded with the proper chain of commands  
     */
    string autoconffile = "";
    if (autogenerate) {
        /**create an empty network representation. 
         */
        Domain pdm = Domain();
        /**create a parser object. the configuration file and the network domain are the parameters. 
         */
        Parser parserp(((char *) filename.c_str()), &pdm);
        /**Build PlanetLab Domain out of the planetlab available node file input
         */
        ret = parserp.buildPlanetLabDomain();
        /**Global domain parameteres should be explicitly called at this stage
         */
        ret = parserp.getGlobalDomainParameters();
        /**Check for errors
         */
        if (ret < 0) {
            cout << "Get global domain parameters: Something went wrong: " << ret << endl;
            return EXIT_FAILURE;
        }
        /**create a graph representation of the network domain. if autogenerated is true, the an igraph instance will be now created using the Barabasi-Albert model 
         */
        GraphRepresentation graphp = GraphRepresentation(&pdm, autogenerate);
        /** the igraph barabasi instance previously created will be traversed, to build 
            the deployment tool internal representation so that click configuration file generation and deployment execution
            can be carried out by the same code with the non-autogenerated graph input. 
         */
        graphp.BuildInputMap();
        graphp.ChooseTheBestTMRVNode();
        /**Write albert-barabasi autogenerated standard configuration file format
         */
        autoconffile = pdm.writeConfigFile("autogenerated.cfg");
        /**Calculate leaf Vertices
         */
        graphp.OutputLeafVertices("edgevertices.cfg");
    }

    /**create an empty network representation. 
     */
    Domain dm = Domain();
    /**create a parser object. the configuration file and the network domain are the parameters. 
     */
    string parserinputfile = "";
    if (autogenerate) {
        parserinputfile = autoconffile;
    } else {
        parserinputfile = filename;
    }
    Parser parser(((char *) parserinputfile.c_str()), &dm);
    if (!ns3) {
        /**In the typical scenario parse the configuration file and build the network domain (add nodes and connections).
         */
        ret = parser.buildNetworkDomain();
    } else {
        ret = parser.buildNS3NetworkDomain();
    }
    /** Check for errors
     */
    if (ret < 0) {
        cout << "Build network domain: Something went wrong: " << ret << endl;
        return EXIT_FAILURE;
    }
    /**create a graph representation of the network domain. if autogenerated is true, the an igraph instance will be now created using the Barabasi-Albert model 
     */
    GraphRepresentation graph = GraphRepresentation(&dm, autogenerate);
    /**assign Link Identifiers and internal link identifiers using a randomly generated set of LIDs.
     */
    dm.assignLIDs();
    /**transform the network domain representation to iGraph representation.
     */
    graph.buildIGraphTopology();
    /**Calculate the default forwarding identifiers from each node to the domain's Rendezvous Node.
     */
    graph.calculateRVFIDs();
    /**Calculate the default forwarding identifiers from each node to the domain's Topology Manager.
     */
    graph.calculateTMFIDs();
    /**discover the MAC addresses (when needed) for each connection in the network domain.
     */
    if (!ns3) {
        dm.discoverMacAddresses(no_discover);
    } else {
        dm.assignDeviceNamesAndMacAddresses();
    }
    /**write all Click/Blackadder Configuration files.
     */
    if (!ns3) {
        dm.writeClickFiles(monitor_tool_stub, dump_supp);
    } else {
        dm.writeNS3ClickFiles();
    }
    /**Tranfer a .tgz file from path to all nodes and also issue a tar zxvf command.
     */
    if (transfer_binaries and !no_copy) {
        dm.scpClickBinary(tgzfile);
    }
    /**copy the Click configuration to each blackadder node.
     */
    if (!ns3) {
        /**copy the Click configuration to each Blackadder node.
         */
        if (!no_copy) {
        	dm.scpClickFiles();
	}
        /**Start Click using the copied configuration file.
         */
        if (!no_start) {
        	dm.startClick();
    	}
    }
    /**set some graph attributes for the topology manager
     */
    igraph_cattribute_GAN_set(&graph.igraph, "FID_LEN", dm.fid_len);
    igraph_cattribute_GAS_set(&graph.igraph, "TM", dm.TM_node->label.c_str());
    igraph_cattribute_GAS_set(&graph.igraph, "RV", dm.RV_node->label.c_str());
    cout << "TM is " << dm.TM_node->label << endl;
    cout << "RV is " << dm.RV_node->label << endl;
    igraph_cattribute_GAS_set(&graph.igraph, "TM_MODE", dm.TM_node->running_mode.c_str());
    FILE * outstream_graphml = fopen(string(dm.write_conf + "topology.graphml").c_str(), "w");
    // The following happens if BA has been previously deployed from another machine
    // so the file exists with root permissions. 
    if (outstream_graphml == NULL){
      cout<<"Could not open file "<<string(dm.write_conf + "topology.graphml")<<"\n";
      cout<<"Try 'sudo rm "<<string(dm.write_conf + "topology.graphml")<<"' and re-deploy...\n";
      return -13;
    }
    igraph_write_graph_graphml(&graph.igraph, outstream_graphml);
    fclose(outstream_graphml);
    if (!ns3) {
        /** Copy the .graphml file to the Topology Manager node.
         */
        if (!no_copy) {
           dm.scpTMConfiguration("topology.graphml");
    	}
        /**Start the Topology Manager at the right node.
         */
        //dm.startTM();
    }
    if (ns3) {
        dm.createNS3SimulationCode();
    }
    cout << "Done." << endl;
}
